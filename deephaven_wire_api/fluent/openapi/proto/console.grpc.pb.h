// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: console.proto
// Original file comments:
//
// Copyright (c) 2016-2021 Deephaven Data Labs and Patent Pending
//
#ifndef GRPC_console_2eproto__INCLUDED
#define GRPC_console_2eproto__INCLUDED

#include "console.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace io {
namespace deephaven {
namespace proto {
namespace backplane {
namespace script {
namespace grpc {

//
// Console interaction service
class ConsoleService final {
 public:
  static constexpr char const* service_full_name() {
    return "io.deephaven.proto.backplane.script.grpc.ConsoleService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status StartConsole(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::StartConsoleRequest& request, ::io::deephaven::proto::backplane::script::grpc::StartConsoleResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::StartConsoleResponse>> AsyncStartConsole(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::StartConsoleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::StartConsoleResponse>>(AsyncStartConsoleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::StartConsoleResponse>> PrepareAsyncStartConsole(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::StartConsoleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::StartConsoleResponse>>(PrepareAsyncStartConsoleRaw(context, request, cq));
    }
    virtual ::grpc::Status GetConsoleTypes(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesRequest& request, ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesResponse>> AsyncGetConsoleTypes(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesResponse>>(AsyncGetConsoleTypesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesResponse>> PrepareAsyncGetConsoleTypes(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesResponse>>(PrepareAsyncGetConsoleTypesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionData>> SubscribeToLogs(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionData>>(SubscribeToLogsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionData>> AsyncSubscribeToLogs(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionData>>(AsyncSubscribeToLogsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionData>> PrepareAsyncSubscribeToLogs(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionData>>(PrepareAsyncSubscribeToLogsRaw(context, request, cq));
    }
    virtual ::grpc::Status ExecuteCommand(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandRequest& request, ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandResponse>> AsyncExecuteCommand(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandResponse>>(AsyncExecuteCommandRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandResponse>> PrepareAsyncExecuteCommand(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandResponse>>(PrepareAsyncExecuteCommandRaw(context, request, cq));
    }
    virtual ::grpc::Status CancelCommand(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::CancelCommandRequest& request, ::io::deephaven::proto::backplane::script::grpc::CancelCommandResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::CancelCommandResponse>> AsyncCancelCommand(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::CancelCommandRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::CancelCommandResponse>>(AsyncCancelCommandRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::CancelCommandResponse>> PrepareAsyncCancelCommand(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::CancelCommandRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::CancelCommandResponse>>(PrepareAsyncCancelCommandRaw(context, request, cq));
    }
    virtual ::grpc::Status BindTableToVariable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableRequest& request, ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableResponse>> AsyncBindTableToVariable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableResponse>>(AsyncBindTableToVariableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableResponse>> PrepareAsyncBindTableToVariable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableResponse>>(PrepareAsyncBindTableToVariableRaw(context, request, cq));
    }
    virtual ::grpc::Status OpenDocument(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::OpenDocumentRequest& request, ::io::deephaven::proto::backplane::script::grpc::OpenDocumentResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::OpenDocumentResponse>> AsyncOpenDocument(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::OpenDocumentRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::OpenDocumentResponse>>(AsyncOpenDocumentRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::OpenDocumentResponse>> PrepareAsyncOpenDocument(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::OpenDocumentRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::OpenDocumentResponse>>(PrepareAsyncOpenDocumentRaw(context, request, cq));
    }
    virtual ::grpc::Status ChangeDocument(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest& request, ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentResponse>> AsyncChangeDocument(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentResponse>>(AsyncChangeDocumentRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentResponse>> PrepareAsyncChangeDocument(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentResponse>>(PrepareAsyncChangeDocumentRaw(context, request, cq));
    }
    virtual ::grpc::Status GetCompletionItems(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsRequest& request, ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse>> AsyncGetCompletionItems(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse>>(AsyncGetCompletionItemsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse>> PrepareAsyncGetCompletionItems(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse>>(PrepareAsyncGetCompletionItemsRaw(context, request, cq));
    }
    virtual ::grpc::Status CloseDocument(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::CloseDocumentRequest& request, ::io::deephaven::proto::backplane::script::grpc::CloseDocumentResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::CloseDocumentResponse>> AsyncCloseDocument(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::CloseDocumentRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::CloseDocumentResponse>>(AsyncCloseDocumentRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::CloseDocumentResponse>> PrepareAsyncCloseDocument(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::CloseDocumentRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::CloseDocumentResponse>>(PrepareAsyncCloseDocumentRaw(context, request, cq));
    }
    virtual ::grpc::Status FetchTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchTableRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncFetchTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchTableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncFetchTableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncFetchTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchTableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncFetchTableRaw(context, request, cq));
    }
    virtual ::grpc::Status FetchPandasTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchPandasTableRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncFetchPandasTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchPandasTableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncFetchPandasTableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncFetchPandasTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchPandasTableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncFetchPandasTableRaw(context, request, cq));
    }
    virtual ::grpc::Status FetchFigure(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchFigureRequest& request, ::io::deephaven::proto::backplane::script::grpc::FetchFigureResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::FetchFigureResponse>> AsyncFetchFigure(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchFigureRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::FetchFigureResponse>>(AsyncFetchFigureRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::FetchFigureResponse>> PrepareAsyncFetchFigure(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchFigureRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::FetchFigureResponse>>(PrepareAsyncFetchFigureRaw(context, request, cq));
    }
    virtual ::grpc::Status FetchTableMap(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchTableMapRequest& request, ::io::deephaven::proto::backplane::script::grpc::FetchTableMapResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::FetchTableMapResponse>> AsyncFetchTableMap(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchTableMapRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::FetchTableMapResponse>>(AsyncFetchTableMapRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::FetchTableMapResponse>> PrepareAsyncFetchTableMap(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchTableMapRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::FetchTableMapResponse>>(PrepareAsyncFetchTableMapRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void StartConsole(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::StartConsoleRequest* request, ::io::deephaven::proto::backplane::script::grpc::StartConsoleResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void StartConsole(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::StartConsoleRequest* request, ::io::deephaven::proto::backplane::script::grpc::StartConsoleResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void StartConsole(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::StartConsoleRequest* request, ::io::deephaven::proto::backplane::script::grpc::StartConsoleResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void GetConsoleTypes(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesRequest* request, ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetConsoleTypes(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesRequest* request, ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetConsoleTypes(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesRequest* request, ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SubscribeToLogs(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionRequest* request, ::grpc::ClientReadReactor< ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionData>* reactor) = 0;
      #else
      virtual void SubscribeToLogs(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionRequest* request, ::grpc::experimental::ClientReadReactor< ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionData>* reactor) = 0;
      #endif
      virtual void ExecuteCommand(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandRequest* request, ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ExecuteCommand(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandRequest* request, ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ExecuteCommand(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandRequest* request, ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void CancelCommand(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::CancelCommandRequest* request, ::io::deephaven::proto::backplane::script::grpc::CancelCommandResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void CancelCommand(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::CancelCommandRequest* request, ::io::deephaven::proto::backplane::script::grpc::CancelCommandResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void CancelCommand(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::CancelCommandRequest* request, ::io::deephaven::proto::backplane::script::grpc::CancelCommandResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void BindTableToVariable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableRequest* request, ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void BindTableToVariable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableRequest* request, ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void BindTableToVariable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableRequest* request, ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void OpenDocument(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::OpenDocumentRequest* request, ::io::deephaven::proto::backplane::script::grpc::OpenDocumentResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void OpenDocument(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::OpenDocumentRequest* request, ::io::deephaven::proto::backplane::script::grpc::OpenDocumentResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void OpenDocument(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::OpenDocumentRequest* request, ::io::deephaven::proto::backplane::script::grpc::OpenDocumentResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void ChangeDocument(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest* request, ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ChangeDocument(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest* request, ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ChangeDocument(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest* request, ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void GetCompletionItems(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsRequest* request, ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetCompletionItems(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsRequest* request, ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetCompletionItems(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsRequest* request, ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void CloseDocument(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::CloseDocumentRequest* request, ::io::deephaven::proto::backplane::script::grpc::CloseDocumentResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void CloseDocument(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::CloseDocumentRequest* request, ::io::deephaven::proto::backplane::script::grpc::CloseDocumentResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void CloseDocument(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::CloseDocumentRequest* request, ::io::deephaven::proto::backplane::script::grpc::CloseDocumentResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void FetchTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void FetchTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void FetchTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void FetchPandasTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchPandasTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void FetchPandasTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchPandasTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void FetchPandasTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchPandasTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void FetchFigure(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchFigureRequest* request, ::io::deephaven::proto::backplane::script::grpc::FetchFigureResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void FetchFigure(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchFigureRequest* request, ::io::deephaven::proto::backplane::script::grpc::FetchFigureResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void FetchFigure(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchFigureRequest* request, ::io::deephaven::proto::backplane::script::grpc::FetchFigureResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void FetchTableMap(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchTableMapRequest* request, ::io::deephaven::proto::backplane::script::grpc::FetchTableMapResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void FetchTableMap(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchTableMapRequest* request, ::io::deephaven::proto::backplane::script::grpc::FetchTableMapResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void FetchTableMap(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchTableMapRequest* request, ::io::deephaven::proto::backplane::script::grpc::FetchTableMapResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::StartConsoleResponse>* AsyncStartConsoleRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::StartConsoleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::StartConsoleResponse>* PrepareAsyncStartConsoleRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::StartConsoleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesResponse>* AsyncGetConsoleTypesRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesResponse>* PrepareAsyncGetConsoleTypesRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionData>* SubscribeToLogsRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionData>* AsyncSubscribeToLogsRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionData>* PrepareAsyncSubscribeToLogsRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandResponse>* AsyncExecuteCommandRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandResponse>* PrepareAsyncExecuteCommandRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::CancelCommandResponse>* AsyncCancelCommandRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::CancelCommandRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::CancelCommandResponse>* PrepareAsyncCancelCommandRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::CancelCommandRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableResponse>* AsyncBindTableToVariableRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableResponse>* PrepareAsyncBindTableToVariableRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::OpenDocumentResponse>* AsyncOpenDocumentRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::OpenDocumentRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::OpenDocumentResponse>* PrepareAsyncOpenDocumentRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::OpenDocumentRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentResponse>* AsyncChangeDocumentRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentResponse>* PrepareAsyncChangeDocumentRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse>* AsyncGetCompletionItemsRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse>* PrepareAsyncGetCompletionItemsRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::CloseDocumentResponse>* AsyncCloseDocumentRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::CloseDocumentRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::CloseDocumentResponse>* PrepareAsyncCloseDocumentRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::CloseDocumentRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncFetchTableRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchTableRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncFetchTableRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchTableRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncFetchPandasTableRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchPandasTableRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncFetchPandasTableRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchPandasTableRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::FetchFigureResponse>* AsyncFetchFigureRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchFigureRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::FetchFigureResponse>* PrepareAsyncFetchFigureRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchFigureRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::FetchTableMapResponse>* AsyncFetchTableMapRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchTableMapRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::script::grpc::FetchTableMapResponse>* PrepareAsyncFetchTableMapRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchTableMapRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status StartConsole(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::StartConsoleRequest& request, ::io::deephaven::proto::backplane::script::grpc::StartConsoleResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::StartConsoleResponse>> AsyncStartConsole(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::StartConsoleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::StartConsoleResponse>>(AsyncStartConsoleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::StartConsoleResponse>> PrepareAsyncStartConsole(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::StartConsoleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::StartConsoleResponse>>(PrepareAsyncStartConsoleRaw(context, request, cq));
    }
    ::grpc::Status GetConsoleTypes(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesRequest& request, ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesResponse>> AsyncGetConsoleTypes(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesResponse>>(AsyncGetConsoleTypesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesResponse>> PrepareAsyncGetConsoleTypes(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesResponse>>(PrepareAsyncGetConsoleTypesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionData>> SubscribeToLogs(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionData>>(SubscribeToLogsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionData>> AsyncSubscribeToLogs(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionData>>(AsyncSubscribeToLogsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionData>> PrepareAsyncSubscribeToLogs(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionData>>(PrepareAsyncSubscribeToLogsRaw(context, request, cq));
    }
    ::grpc::Status ExecuteCommand(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandRequest& request, ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandResponse>> AsyncExecuteCommand(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandResponse>>(AsyncExecuteCommandRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandResponse>> PrepareAsyncExecuteCommand(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandResponse>>(PrepareAsyncExecuteCommandRaw(context, request, cq));
    }
    ::grpc::Status CancelCommand(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::CancelCommandRequest& request, ::io::deephaven::proto::backplane::script::grpc::CancelCommandResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::CancelCommandResponse>> AsyncCancelCommand(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::CancelCommandRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::CancelCommandResponse>>(AsyncCancelCommandRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::CancelCommandResponse>> PrepareAsyncCancelCommand(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::CancelCommandRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::CancelCommandResponse>>(PrepareAsyncCancelCommandRaw(context, request, cq));
    }
    ::grpc::Status BindTableToVariable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableRequest& request, ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableResponse>> AsyncBindTableToVariable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableResponse>>(AsyncBindTableToVariableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableResponse>> PrepareAsyncBindTableToVariable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableResponse>>(PrepareAsyncBindTableToVariableRaw(context, request, cq));
    }
    ::grpc::Status OpenDocument(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::OpenDocumentRequest& request, ::io::deephaven::proto::backplane::script::grpc::OpenDocumentResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::OpenDocumentResponse>> AsyncOpenDocument(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::OpenDocumentRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::OpenDocumentResponse>>(AsyncOpenDocumentRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::OpenDocumentResponse>> PrepareAsyncOpenDocument(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::OpenDocumentRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::OpenDocumentResponse>>(PrepareAsyncOpenDocumentRaw(context, request, cq));
    }
    ::grpc::Status ChangeDocument(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest& request, ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentResponse>> AsyncChangeDocument(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentResponse>>(AsyncChangeDocumentRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentResponse>> PrepareAsyncChangeDocument(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentResponse>>(PrepareAsyncChangeDocumentRaw(context, request, cq));
    }
    ::grpc::Status GetCompletionItems(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsRequest& request, ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse>> AsyncGetCompletionItems(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse>>(AsyncGetCompletionItemsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse>> PrepareAsyncGetCompletionItems(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse>>(PrepareAsyncGetCompletionItemsRaw(context, request, cq));
    }
    ::grpc::Status CloseDocument(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::CloseDocumentRequest& request, ::io::deephaven::proto::backplane::script::grpc::CloseDocumentResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::CloseDocumentResponse>> AsyncCloseDocument(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::CloseDocumentRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::CloseDocumentResponse>>(AsyncCloseDocumentRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::CloseDocumentResponse>> PrepareAsyncCloseDocument(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::CloseDocumentRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::CloseDocumentResponse>>(PrepareAsyncCloseDocumentRaw(context, request, cq));
    }
    ::grpc::Status FetchTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchTableRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncFetchTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchTableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncFetchTableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncFetchTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchTableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncFetchTableRaw(context, request, cq));
    }
    ::grpc::Status FetchPandasTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchPandasTableRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncFetchPandasTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchPandasTableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncFetchPandasTableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncFetchPandasTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchPandasTableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncFetchPandasTableRaw(context, request, cq));
    }
    ::grpc::Status FetchFigure(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchFigureRequest& request, ::io::deephaven::proto::backplane::script::grpc::FetchFigureResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::FetchFigureResponse>> AsyncFetchFigure(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchFigureRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::FetchFigureResponse>>(AsyncFetchFigureRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::FetchFigureResponse>> PrepareAsyncFetchFigure(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchFigureRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::FetchFigureResponse>>(PrepareAsyncFetchFigureRaw(context, request, cq));
    }
    ::grpc::Status FetchTableMap(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchTableMapRequest& request, ::io::deephaven::proto::backplane::script::grpc::FetchTableMapResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::FetchTableMapResponse>> AsyncFetchTableMap(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchTableMapRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::FetchTableMapResponse>>(AsyncFetchTableMapRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::FetchTableMapResponse>> PrepareAsyncFetchTableMap(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchTableMapRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::FetchTableMapResponse>>(PrepareAsyncFetchTableMapRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void StartConsole(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::StartConsoleRequest* request, ::io::deephaven::proto::backplane::script::grpc::StartConsoleResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void StartConsole(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::StartConsoleRequest* request, ::io::deephaven::proto::backplane::script::grpc::StartConsoleResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void StartConsole(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::StartConsoleRequest* request, ::io::deephaven::proto::backplane::script::grpc::StartConsoleResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetConsoleTypes(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesRequest* request, ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetConsoleTypes(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesRequest* request, ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetConsoleTypes(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesRequest* request, ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SubscribeToLogs(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionRequest* request, ::grpc::ClientReadReactor< ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionData>* reactor) override;
      #else
      void SubscribeToLogs(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionRequest* request, ::grpc::experimental::ClientReadReactor< ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionData>* reactor) override;
      #endif
      void ExecuteCommand(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandRequest* request, ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ExecuteCommand(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandRequest* request, ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ExecuteCommand(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandRequest* request, ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void CancelCommand(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::CancelCommandRequest* request, ::io::deephaven::proto::backplane::script::grpc::CancelCommandResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void CancelCommand(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::CancelCommandRequest* request, ::io::deephaven::proto::backplane::script::grpc::CancelCommandResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void CancelCommand(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::CancelCommandRequest* request, ::io::deephaven::proto::backplane::script::grpc::CancelCommandResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void BindTableToVariable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableRequest* request, ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void BindTableToVariable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableRequest* request, ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void BindTableToVariable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableRequest* request, ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void OpenDocument(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::OpenDocumentRequest* request, ::io::deephaven::proto::backplane::script::grpc::OpenDocumentResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void OpenDocument(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::OpenDocumentRequest* request, ::io::deephaven::proto::backplane::script::grpc::OpenDocumentResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void OpenDocument(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::OpenDocumentRequest* request, ::io::deephaven::proto::backplane::script::grpc::OpenDocumentResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ChangeDocument(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest* request, ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ChangeDocument(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest* request, ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ChangeDocument(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest* request, ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetCompletionItems(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsRequest* request, ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetCompletionItems(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsRequest* request, ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetCompletionItems(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsRequest* request, ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void CloseDocument(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::CloseDocumentRequest* request, ::io::deephaven::proto::backplane::script::grpc::CloseDocumentResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void CloseDocument(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::CloseDocumentRequest* request, ::io::deephaven::proto::backplane::script::grpc::CloseDocumentResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void CloseDocument(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::CloseDocumentRequest* request, ::io::deephaven::proto::backplane::script::grpc::CloseDocumentResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void FetchTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void FetchTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void FetchTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void FetchPandasTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchPandasTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void FetchPandasTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchPandasTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void FetchPandasTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchPandasTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void FetchFigure(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchFigureRequest* request, ::io::deephaven::proto::backplane::script::grpc::FetchFigureResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void FetchFigure(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchFigureRequest* request, ::io::deephaven::proto::backplane::script::grpc::FetchFigureResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void FetchFigure(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchFigureRequest* request, ::io::deephaven::proto::backplane::script::grpc::FetchFigureResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void FetchTableMap(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchTableMapRequest* request, ::io::deephaven::proto::backplane::script::grpc::FetchTableMapResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void FetchTableMap(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchTableMapRequest* request, ::io::deephaven::proto::backplane::script::grpc::FetchTableMapResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void FetchTableMap(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchTableMapRequest* request, ::io::deephaven::proto::backplane::script::grpc::FetchTableMapResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::StartConsoleResponse>* AsyncStartConsoleRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::StartConsoleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::StartConsoleResponse>* PrepareAsyncStartConsoleRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::StartConsoleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesResponse>* AsyncGetConsoleTypesRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesResponse>* PrepareAsyncGetConsoleTypesRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionData>* SubscribeToLogsRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionRequest& request) override;
    ::grpc::ClientAsyncReader< ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionData>* AsyncSubscribeToLogsRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionData>* PrepareAsyncSubscribeToLogsRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandResponse>* AsyncExecuteCommandRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandResponse>* PrepareAsyncExecuteCommandRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::CancelCommandResponse>* AsyncCancelCommandRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::CancelCommandRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::CancelCommandResponse>* PrepareAsyncCancelCommandRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::CancelCommandRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableResponse>* AsyncBindTableToVariableRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableResponse>* PrepareAsyncBindTableToVariableRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::OpenDocumentResponse>* AsyncOpenDocumentRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::OpenDocumentRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::OpenDocumentResponse>* PrepareAsyncOpenDocumentRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::OpenDocumentRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentResponse>* AsyncChangeDocumentRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentResponse>* PrepareAsyncChangeDocumentRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse>* AsyncGetCompletionItemsRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse>* PrepareAsyncGetCompletionItemsRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::CloseDocumentResponse>* AsyncCloseDocumentRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::CloseDocumentRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::CloseDocumentResponse>* PrepareAsyncCloseDocumentRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::CloseDocumentRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncFetchTableRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchTableRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncFetchTableRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchTableRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncFetchPandasTableRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchPandasTableRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncFetchPandasTableRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchPandasTableRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::FetchFigureResponse>* AsyncFetchFigureRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchFigureRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::FetchFigureResponse>* PrepareAsyncFetchFigureRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchFigureRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::FetchTableMapResponse>* AsyncFetchTableMapRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchTableMapRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::script::grpc::FetchTableMapResponse>* PrepareAsyncFetchTableMapRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchTableMapRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_StartConsole_;
    const ::grpc::internal::RpcMethod rpcmethod_GetConsoleTypes_;
    const ::grpc::internal::RpcMethod rpcmethod_SubscribeToLogs_;
    const ::grpc::internal::RpcMethod rpcmethod_ExecuteCommand_;
    const ::grpc::internal::RpcMethod rpcmethod_CancelCommand_;
    const ::grpc::internal::RpcMethod rpcmethod_BindTableToVariable_;
    const ::grpc::internal::RpcMethod rpcmethod_OpenDocument_;
    const ::grpc::internal::RpcMethod rpcmethod_ChangeDocument_;
    const ::grpc::internal::RpcMethod rpcmethod_GetCompletionItems_;
    const ::grpc::internal::RpcMethod rpcmethod_CloseDocument_;
    const ::grpc::internal::RpcMethod rpcmethod_FetchTable_;
    const ::grpc::internal::RpcMethod rpcmethod_FetchPandasTable_;
    const ::grpc::internal::RpcMethod rpcmethod_FetchFigure_;
    const ::grpc::internal::RpcMethod rpcmethod_FetchTableMap_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status StartConsole(::grpc::ServerContext* context, const ::io::deephaven::proto::backplane::script::grpc::StartConsoleRequest* request, ::io::deephaven::proto::backplane::script::grpc::StartConsoleResponse* response);
    virtual ::grpc::Status GetConsoleTypes(::grpc::ServerContext* context, const ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesRequest* request, ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesResponse* response);
    virtual ::grpc::Status SubscribeToLogs(::grpc::ServerContext* context, const ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionRequest* request, ::grpc::ServerWriter< ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionData>* writer);
    virtual ::grpc::Status ExecuteCommand(::grpc::ServerContext* context, const ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandRequest* request, ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandResponse* response);
    virtual ::grpc::Status CancelCommand(::grpc::ServerContext* context, const ::io::deephaven::proto::backplane::script::grpc::CancelCommandRequest* request, ::io::deephaven::proto::backplane::script::grpc::CancelCommandResponse* response);
    virtual ::grpc::Status BindTableToVariable(::grpc::ServerContext* context, const ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableRequest* request, ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableResponse* response);
    virtual ::grpc::Status OpenDocument(::grpc::ServerContext* context, const ::io::deephaven::proto::backplane::script::grpc::OpenDocumentRequest* request, ::io::deephaven::proto::backplane::script::grpc::OpenDocumentResponse* response);
    virtual ::grpc::Status ChangeDocument(::grpc::ServerContext* context, const ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest* request, ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentResponse* response);
    virtual ::grpc::Status GetCompletionItems(::grpc::ServerContext* context, const ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsRequest* request, ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse* response);
    virtual ::grpc::Status CloseDocument(::grpc::ServerContext* context, const ::io::deephaven::proto::backplane::script::grpc::CloseDocumentRequest* request, ::io::deephaven::proto::backplane::script::grpc::CloseDocumentResponse* response);
    virtual ::grpc::Status FetchTable(::grpc::ServerContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response);
    virtual ::grpc::Status FetchPandasTable(::grpc::ServerContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchPandasTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response);
    virtual ::grpc::Status FetchFigure(::grpc::ServerContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchFigureRequest* request, ::io::deephaven::proto::backplane::script::grpc::FetchFigureResponse* response);
    virtual ::grpc::Status FetchTableMap(::grpc::ServerContext* context, const ::io::deephaven::proto::backplane::script::grpc::FetchTableMapRequest* request, ::io::deephaven::proto::backplane::script::grpc::FetchTableMapResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_StartConsole : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StartConsole() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_StartConsole() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartConsole(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::StartConsoleRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::StartConsoleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartConsole(::grpc::ServerContext* context, ::io::deephaven::proto::backplane::script::grpc::StartConsoleRequest* request, ::grpc::ServerAsyncResponseWriter< ::io::deephaven::proto::backplane::script::grpc::StartConsoleResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetConsoleTypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetConsoleTypes() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_GetConsoleTypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConsoleTypes(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetConsoleTypes(::grpc::ServerContext* context, ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesRequest* request, ::grpc::ServerAsyncResponseWriter< ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SubscribeToLogs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SubscribeToLogs() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_SubscribeToLogs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeToLogs(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionRequest* /*request*/, ::grpc::ServerWriter< ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribeToLogs(::grpc::ServerContext* context, ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionRequest* request, ::grpc::ServerAsyncWriter< ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionData>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(2, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ExecuteCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ExecuteCommand() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_ExecuteCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteCommand(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExecuteCommand(::grpc::ServerContext* context, ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandRequest* request, ::grpc::ServerAsyncResponseWriter< ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CancelCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CancelCommand() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_CancelCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelCommand(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::CancelCommandRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::CancelCommandResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCancelCommand(::grpc::ServerContext* context, ::io::deephaven::proto::backplane::script::grpc::CancelCommandRequest* request, ::grpc::ServerAsyncResponseWriter< ::io::deephaven::proto::backplane::script::grpc::CancelCommandResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_BindTableToVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_BindTableToVariable() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_BindTableToVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BindTableToVariable(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBindTableToVariable(::grpc::ServerContext* context, ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableRequest* request, ::grpc::ServerAsyncResponseWriter< ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_OpenDocument : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_OpenDocument() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_OpenDocument() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OpenDocument(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::OpenDocumentRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::OpenDocumentResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOpenDocument(::grpc::ServerContext* context, ::io::deephaven::proto::backplane::script::grpc::OpenDocumentRequest* request, ::grpc::ServerAsyncResponseWriter< ::io::deephaven::proto::backplane::script::grpc::OpenDocumentResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ChangeDocument : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ChangeDocument() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_ChangeDocument() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChangeDocument(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestChangeDocument(::grpc::ServerContext* context, ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest* request, ::grpc::ServerAsyncResponseWriter< ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetCompletionItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetCompletionItems() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_GetCompletionItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCompletionItems(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCompletionItems(::grpc::ServerContext* context, ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsRequest* request, ::grpc::ServerAsyncResponseWriter< ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CloseDocument : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CloseDocument() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_CloseDocument() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CloseDocument(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::CloseDocumentRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::CloseDocumentResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCloseDocument(::grpc::ServerContext* context, ::io::deephaven::proto::backplane::script::grpc::CloseDocumentRequest* request, ::grpc::ServerAsyncResponseWriter< ::io::deephaven::proto::backplane::script::grpc::CloseDocumentResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_FetchTable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_FetchTable() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_FetchTable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FetchTable(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::FetchTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFetchTable(::grpc::ServerContext* context, ::io::deephaven::proto::backplane::script::grpc::FetchTableRequest* request, ::grpc::ServerAsyncResponseWriter< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_FetchPandasTable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_FetchPandasTable() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_FetchPandasTable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FetchPandasTable(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::FetchPandasTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFetchPandasTable(::grpc::ServerContext* context, ::io::deephaven::proto::backplane::script::grpc::FetchPandasTableRequest* request, ::grpc::ServerAsyncResponseWriter< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_FetchFigure : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_FetchFigure() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_FetchFigure() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FetchFigure(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::FetchFigureRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::FetchFigureResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFetchFigure(::grpc::ServerContext* context, ::io::deephaven::proto::backplane::script::grpc::FetchFigureRequest* request, ::grpc::ServerAsyncResponseWriter< ::io::deephaven::proto::backplane::script::grpc::FetchFigureResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_FetchTableMap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_FetchTableMap() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_FetchTableMap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FetchTableMap(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::FetchTableMapRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::FetchTableMapResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFetchTableMap(::grpc::ServerContext* context, ::io::deephaven::proto::backplane::script::grpc::FetchTableMapRequest* request, ::grpc::ServerAsyncResponseWriter< ::io::deephaven::proto::backplane::script::grpc::FetchTableMapResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_StartConsole<WithAsyncMethod_GetConsoleTypes<WithAsyncMethod_SubscribeToLogs<WithAsyncMethod_ExecuteCommand<WithAsyncMethod_CancelCommand<WithAsyncMethod_BindTableToVariable<WithAsyncMethod_OpenDocument<WithAsyncMethod_ChangeDocument<WithAsyncMethod_GetCompletionItems<WithAsyncMethod_CloseDocument<WithAsyncMethod_FetchTable<WithAsyncMethod_FetchPandasTable<WithAsyncMethod_FetchFigure<WithAsyncMethod_FetchTableMap<Service > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StartConsole : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_StartConsole() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::script::grpc::StartConsoleRequest, ::io::deephaven::proto::backplane::script::grpc::StartConsoleResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::io::deephaven::proto::backplane::script::grpc::StartConsoleRequest* request, ::io::deephaven::proto::backplane::script::grpc::StartConsoleResponse* response) { return this->StartConsole(context, request, response); }));}
    void SetMessageAllocatorFor_StartConsole(
        ::grpc::experimental::MessageAllocator< ::io::deephaven::proto::backplane::script::grpc::StartConsoleRequest, ::io::deephaven::proto::backplane::script::grpc::StartConsoleResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::script::grpc::StartConsoleRequest, ::io::deephaven::proto::backplane::script::grpc::StartConsoleResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_StartConsole() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartConsole(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::StartConsoleRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::StartConsoleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* StartConsole(
      ::grpc::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::StartConsoleRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::StartConsoleResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* StartConsole(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::StartConsoleRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::StartConsoleResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetConsoleTypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetConsoleTypes() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesRequest, ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesRequest* request, ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesResponse* response) { return this->GetConsoleTypes(context, request, response); }));}
    void SetMessageAllocatorFor_GetConsoleTypes(
        ::grpc::experimental::MessageAllocator< ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesRequest, ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesRequest, ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetConsoleTypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConsoleTypes(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetConsoleTypes(
      ::grpc::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetConsoleTypes(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SubscribeToLogs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SubscribeToLogs() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc::internal::CallbackServerStreamingHandler< ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionRequest, ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionData>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionRequest* request) { return this->SubscribeToLogs(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_SubscribeToLogs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeToLogs(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionRequest* /*request*/, ::grpc::ServerWriter< ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionData>* SubscribeToLogs(
      ::grpc::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionRequest* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionData>* SubscribeToLogs(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionRequest* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ExecuteCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ExecuteCommand() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandRequest, ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandRequest* request, ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandResponse* response) { return this->ExecuteCommand(context, request, response); }));}
    void SetMessageAllocatorFor_ExecuteCommand(
        ::grpc::experimental::MessageAllocator< ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandRequest, ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandRequest, ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ExecuteCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteCommand(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ExecuteCommand(
      ::grpc::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ExecuteCommand(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CancelCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_CancelCommand() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::script::grpc::CancelCommandRequest, ::io::deephaven::proto::backplane::script::grpc::CancelCommandResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::io::deephaven::proto::backplane::script::grpc::CancelCommandRequest* request, ::io::deephaven::proto::backplane::script::grpc::CancelCommandResponse* response) { return this->CancelCommand(context, request, response); }));}
    void SetMessageAllocatorFor_CancelCommand(
        ::grpc::experimental::MessageAllocator< ::io::deephaven::proto::backplane::script::grpc::CancelCommandRequest, ::io::deephaven::proto::backplane::script::grpc::CancelCommandResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::script::grpc::CancelCommandRequest, ::io::deephaven::proto::backplane::script::grpc::CancelCommandResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CancelCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelCommand(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::CancelCommandRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::CancelCommandResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CancelCommand(
      ::grpc::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::CancelCommandRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::CancelCommandResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CancelCommand(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::CancelCommandRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::CancelCommandResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_BindTableToVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_BindTableToVariable() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableRequest, ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableRequest* request, ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableResponse* response) { return this->BindTableToVariable(context, request, response); }));}
    void SetMessageAllocatorFor_BindTableToVariable(
        ::grpc::experimental::MessageAllocator< ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableRequest, ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(5);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableRequest, ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_BindTableToVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BindTableToVariable(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* BindTableToVariable(
      ::grpc::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* BindTableToVariable(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_OpenDocument : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_OpenDocument() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::script::grpc::OpenDocumentRequest, ::io::deephaven::proto::backplane::script::grpc::OpenDocumentResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::io::deephaven::proto::backplane::script::grpc::OpenDocumentRequest* request, ::io::deephaven::proto::backplane::script::grpc::OpenDocumentResponse* response) { return this->OpenDocument(context, request, response); }));}
    void SetMessageAllocatorFor_OpenDocument(
        ::grpc::experimental::MessageAllocator< ::io::deephaven::proto::backplane::script::grpc::OpenDocumentRequest, ::io::deephaven::proto::backplane::script::grpc::OpenDocumentResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(6);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::script::grpc::OpenDocumentRequest, ::io::deephaven::proto::backplane::script::grpc::OpenDocumentResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_OpenDocument() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OpenDocument(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::OpenDocumentRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::OpenDocumentResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* OpenDocument(
      ::grpc::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::OpenDocumentRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::OpenDocumentResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* OpenDocument(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::OpenDocumentRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::OpenDocumentResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ChangeDocument : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ChangeDocument() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest, ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest* request, ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentResponse* response) { return this->ChangeDocument(context, request, response); }));}
    void SetMessageAllocatorFor_ChangeDocument(
        ::grpc::experimental::MessageAllocator< ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest, ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(7);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest, ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ChangeDocument() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChangeDocument(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ChangeDocument(
      ::grpc::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ChangeDocument(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetCompletionItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetCompletionItems() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsRequest, ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsRequest* request, ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse* response) { return this->GetCompletionItems(context, request, response); }));}
    void SetMessageAllocatorFor_GetCompletionItems(
        ::grpc::experimental::MessageAllocator< ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsRequest, ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(8);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsRequest, ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetCompletionItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCompletionItems(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetCompletionItems(
      ::grpc::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetCompletionItems(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CloseDocument : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_CloseDocument() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::script::grpc::CloseDocumentRequest, ::io::deephaven::proto::backplane::script::grpc::CloseDocumentResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::io::deephaven::proto::backplane::script::grpc::CloseDocumentRequest* request, ::io::deephaven::proto::backplane::script::grpc::CloseDocumentResponse* response) { return this->CloseDocument(context, request, response); }));}
    void SetMessageAllocatorFor_CloseDocument(
        ::grpc::experimental::MessageAllocator< ::io::deephaven::proto::backplane::script::grpc::CloseDocumentRequest, ::io::deephaven::proto::backplane::script::grpc::CloseDocumentResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(9);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::script::grpc::CloseDocumentRequest, ::io::deephaven::proto::backplane::script::grpc::CloseDocumentResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CloseDocument() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CloseDocument(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::CloseDocumentRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::CloseDocumentResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CloseDocument(
      ::grpc::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::CloseDocumentRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::CloseDocumentResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CloseDocument(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::CloseDocumentRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::CloseDocumentResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_FetchTable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_FetchTable() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::script::grpc::FetchTableRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::io::deephaven::proto::backplane::script::grpc::FetchTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) { return this->FetchTable(context, request, response); }));}
    void SetMessageAllocatorFor_FetchTable(
        ::grpc::experimental::MessageAllocator< ::io::deephaven::proto::backplane::script::grpc::FetchTableRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(10);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::script::grpc::FetchTableRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_FetchTable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FetchTable(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::FetchTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FetchTable(
      ::grpc::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::FetchTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FetchTable(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::FetchTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_FetchPandasTable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_FetchPandasTable() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::script::grpc::FetchPandasTableRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::io::deephaven::proto::backplane::script::grpc::FetchPandasTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) { return this->FetchPandasTable(context, request, response); }));}
    void SetMessageAllocatorFor_FetchPandasTable(
        ::grpc::experimental::MessageAllocator< ::io::deephaven::proto::backplane::script::grpc::FetchPandasTableRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(11);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::script::grpc::FetchPandasTableRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_FetchPandasTable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FetchPandasTable(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::FetchPandasTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FetchPandasTable(
      ::grpc::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::FetchPandasTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FetchPandasTable(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::FetchPandasTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_FetchFigure : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_FetchFigure() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::script::grpc::FetchFigureRequest, ::io::deephaven::proto::backplane::script::grpc::FetchFigureResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::io::deephaven::proto::backplane::script::grpc::FetchFigureRequest* request, ::io::deephaven::proto::backplane::script::grpc::FetchFigureResponse* response) { return this->FetchFigure(context, request, response); }));}
    void SetMessageAllocatorFor_FetchFigure(
        ::grpc::experimental::MessageAllocator< ::io::deephaven::proto::backplane::script::grpc::FetchFigureRequest, ::io::deephaven::proto::backplane::script::grpc::FetchFigureResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(12);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::script::grpc::FetchFigureRequest, ::io::deephaven::proto::backplane::script::grpc::FetchFigureResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_FetchFigure() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FetchFigure(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::FetchFigureRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::FetchFigureResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FetchFigure(
      ::grpc::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::FetchFigureRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::FetchFigureResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FetchFigure(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::FetchFigureRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::FetchFigureResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_FetchTableMap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_FetchTableMap() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::script::grpc::FetchTableMapRequest, ::io::deephaven::proto::backplane::script::grpc::FetchTableMapResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::io::deephaven::proto::backplane::script::grpc::FetchTableMapRequest* request, ::io::deephaven::proto::backplane::script::grpc::FetchTableMapResponse* response) { return this->FetchTableMap(context, request, response); }));}
    void SetMessageAllocatorFor_FetchTableMap(
        ::grpc::experimental::MessageAllocator< ::io::deephaven::proto::backplane::script::grpc::FetchTableMapRequest, ::io::deephaven::proto::backplane::script::grpc::FetchTableMapResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(13);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::script::grpc::FetchTableMapRequest, ::io::deephaven::proto::backplane::script::grpc::FetchTableMapResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_FetchTableMap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FetchTableMap(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::FetchTableMapRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::FetchTableMapResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FetchTableMap(
      ::grpc::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::FetchTableMapRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::FetchTableMapResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FetchTableMap(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::FetchTableMapRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::FetchTableMapResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_StartConsole<ExperimentalWithCallbackMethod_GetConsoleTypes<ExperimentalWithCallbackMethod_SubscribeToLogs<ExperimentalWithCallbackMethod_ExecuteCommand<ExperimentalWithCallbackMethod_CancelCommand<ExperimentalWithCallbackMethod_BindTableToVariable<ExperimentalWithCallbackMethod_OpenDocument<ExperimentalWithCallbackMethod_ChangeDocument<ExperimentalWithCallbackMethod_GetCompletionItems<ExperimentalWithCallbackMethod_CloseDocument<ExperimentalWithCallbackMethod_FetchTable<ExperimentalWithCallbackMethod_FetchPandasTable<ExperimentalWithCallbackMethod_FetchFigure<ExperimentalWithCallbackMethod_FetchTableMap<Service > > > > > > > > > > > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_StartConsole<ExperimentalWithCallbackMethod_GetConsoleTypes<ExperimentalWithCallbackMethod_SubscribeToLogs<ExperimentalWithCallbackMethod_ExecuteCommand<ExperimentalWithCallbackMethod_CancelCommand<ExperimentalWithCallbackMethod_BindTableToVariable<ExperimentalWithCallbackMethod_OpenDocument<ExperimentalWithCallbackMethod_ChangeDocument<ExperimentalWithCallbackMethod_GetCompletionItems<ExperimentalWithCallbackMethod_CloseDocument<ExperimentalWithCallbackMethod_FetchTable<ExperimentalWithCallbackMethod_FetchPandasTable<ExperimentalWithCallbackMethod_FetchFigure<ExperimentalWithCallbackMethod_FetchTableMap<Service > > > > > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_StartConsole : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StartConsole() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_StartConsole() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartConsole(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::StartConsoleRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::StartConsoleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetConsoleTypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetConsoleTypes() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_GetConsoleTypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConsoleTypes(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SubscribeToLogs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SubscribeToLogs() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_SubscribeToLogs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeToLogs(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionRequest* /*request*/, ::grpc::ServerWriter< ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ExecuteCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ExecuteCommand() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_ExecuteCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteCommand(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CancelCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CancelCommand() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_CancelCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelCommand(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::CancelCommandRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::CancelCommandResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_BindTableToVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_BindTableToVariable() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_BindTableToVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BindTableToVariable(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_OpenDocument : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_OpenDocument() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_OpenDocument() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OpenDocument(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::OpenDocumentRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::OpenDocumentResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ChangeDocument : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ChangeDocument() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_ChangeDocument() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChangeDocument(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetCompletionItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetCompletionItems() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_GetCompletionItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCompletionItems(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CloseDocument : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CloseDocument() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_CloseDocument() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CloseDocument(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::CloseDocumentRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::CloseDocumentResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_FetchTable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_FetchTable() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_FetchTable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FetchTable(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::FetchTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_FetchPandasTable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_FetchPandasTable() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_FetchPandasTable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FetchPandasTable(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::FetchPandasTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_FetchFigure : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_FetchFigure() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_FetchFigure() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FetchFigure(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::FetchFigureRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::FetchFigureResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_FetchTableMap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_FetchTableMap() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_FetchTableMap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FetchTableMap(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::FetchTableMapRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::FetchTableMapResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_StartConsole : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StartConsole() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_StartConsole() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartConsole(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::StartConsoleRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::StartConsoleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartConsole(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetConsoleTypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetConsoleTypes() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_GetConsoleTypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConsoleTypes(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetConsoleTypes(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SubscribeToLogs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SubscribeToLogs() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_SubscribeToLogs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeToLogs(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionRequest* /*request*/, ::grpc::ServerWriter< ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribeToLogs(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(2, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ExecuteCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ExecuteCommand() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_ExecuteCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteCommand(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExecuteCommand(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CancelCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CancelCommand() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_CancelCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelCommand(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::CancelCommandRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::CancelCommandResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCancelCommand(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_BindTableToVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_BindTableToVariable() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_BindTableToVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BindTableToVariable(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBindTableToVariable(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_OpenDocument : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_OpenDocument() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_OpenDocument() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OpenDocument(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::OpenDocumentRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::OpenDocumentResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOpenDocument(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ChangeDocument : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ChangeDocument() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_ChangeDocument() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChangeDocument(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestChangeDocument(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetCompletionItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetCompletionItems() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_GetCompletionItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCompletionItems(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCompletionItems(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CloseDocument : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CloseDocument() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_CloseDocument() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CloseDocument(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::CloseDocumentRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::CloseDocumentResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCloseDocument(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_FetchTable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_FetchTable() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_FetchTable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FetchTable(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::FetchTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFetchTable(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_FetchPandasTable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_FetchPandasTable() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_FetchPandasTable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FetchPandasTable(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::FetchPandasTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFetchPandasTable(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_FetchFigure : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_FetchFigure() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_FetchFigure() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FetchFigure(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::FetchFigureRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::FetchFigureResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFetchFigure(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_FetchTableMap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_FetchTableMap() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_FetchTableMap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FetchTableMap(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::FetchTableMapRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::FetchTableMapResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFetchTableMap(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StartConsole : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_StartConsole() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->StartConsole(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_StartConsole() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartConsole(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::StartConsoleRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::StartConsoleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* StartConsole(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* StartConsole(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetConsoleTypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetConsoleTypes() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetConsoleTypes(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetConsoleTypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConsoleTypes(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetConsoleTypes(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetConsoleTypes(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SubscribeToLogs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SubscribeToLogs() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->SubscribeToLogs(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_SubscribeToLogs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeToLogs(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionRequest* /*request*/, ::grpc::ServerWriter< ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* SubscribeToLogs(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* SubscribeToLogs(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ExecuteCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ExecuteCommand() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ExecuteCommand(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ExecuteCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteCommand(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ExecuteCommand(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ExecuteCommand(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CancelCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_CancelCommand() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CancelCommand(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_CancelCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelCommand(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::CancelCommandRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::CancelCommandResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CancelCommand(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CancelCommand(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_BindTableToVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_BindTableToVariable() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->BindTableToVariable(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_BindTableToVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BindTableToVariable(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* BindTableToVariable(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* BindTableToVariable(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_OpenDocument : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_OpenDocument() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->OpenDocument(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_OpenDocument() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OpenDocument(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::OpenDocumentRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::OpenDocumentResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* OpenDocument(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* OpenDocument(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ChangeDocument : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ChangeDocument() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ChangeDocument(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ChangeDocument() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChangeDocument(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ChangeDocument(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ChangeDocument(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetCompletionItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetCompletionItems() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetCompletionItems(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetCompletionItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCompletionItems(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetCompletionItems(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetCompletionItems(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CloseDocument : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_CloseDocument() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CloseDocument(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_CloseDocument() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CloseDocument(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::CloseDocumentRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::CloseDocumentResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CloseDocument(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CloseDocument(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_FetchTable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_FetchTable() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->FetchTable(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_FetchTable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FetchTable(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::FetchTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FetchTable(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FetchTable(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_FetchPandasTable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_FetchPandasTable() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->FetchPandasTable(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_FetchPandasTable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FetchPandasTable(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::FetchPandasTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FetchPandasTable(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FetchPandasTable(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_FetchFigure : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_FetchFigure() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->FetchFigure(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_FetchFigure() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FetchFigure(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::FetchFigureRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::FetchFigureResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FetchFigure(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FetchFigure(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_FetchTableMap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_FetchTableMap() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->FetchTableMap(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_FetchTableMap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FetchTableMap(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::FetchTableMapRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::FetchTableMapResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FetchTableMap(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FetchTableMap(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StartConsole : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_StartConsole() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::io::deephaven::proto::backplane::script::grpc::StartConsoleRequest, ::io::deephaven::proto::backplane::script::grpc::StartConsoleResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::io::deephaven::proto::backplane::script::grpc::StartConsoleRequest, ::io::deephaven::proto::backplane::script::grpc::StartConsoleResponse>* streamer) {
                       return this->StreamedStartConsole(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_StartConsole() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StartConsole(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::StartConsoleRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::StartConsoleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStartConsole(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::io::deephaven::proto::backplane::script::grpc::StartConsoleRequest,::io::deephaven::proto::backplane::script::grpc::StartConsoleResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetConsoleTypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetConsoleTypes() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesRequest, ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesRequest, ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesResponse>* streamer) {
                       return this->StreamedGetConsoleTypes(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetConsoleTypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetConsoleTypes(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetConsoleTypes(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesRequest,::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ExecuteCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ExecuteCommand() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandRequest, ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandRequest, ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandResponse>* streamer) {
                       return this->StreamedExecuteCommand(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ExecuteCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ExecuteCommand(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedExecuteCommand(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandRequest,::io::deephaven::proto::backplane::script::grpc::ExecuteCommandResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CancelCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CancelCommand() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::io::deephaven::proto::backplane::script::grpc::CancelCommandRequest, ::io::deephaven::proto::backplane::script::grpc::CancelCommandResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::io::deephaven::proto::backplane::script::grpc::CancelCommandRequest, ::io::deephaven::proto::backplane::script::grpc::CancelCommandResponse>* streamer) {
                       return this->StreamedCancelCommand(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CancelCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CancelCommand(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::CancelCommandRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::CancelCommandResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCancelCommand(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::io::deephaven::proto::backplane::script::grpc::CancelCommandRequest,::io::deephaven::proto::backplane::script::grpc::CancelCommandResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_BindTableToVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_BindTableToVariable() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableRequest, ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableRequest, ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableResponse>* streamer) {
                       return this->StreamedBindTableToVariable(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_BindTableToVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status BindTableToVariable(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedBindTableToVariable(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableRequest,::io::deephaven::proto::backplane::script::grpc::BindTableToVariableResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_OpenDocument : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_OpenDocument() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::io::deephaven::proto::backplane::script::grpc::OpenDocumentRequest, ::io::deephaven::proto::backplane::script::grpc::OpenDocumentResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::io::deephaven::proto::backplane::script::grpc::OpenDocumentRequest, ::io::deephaven::proto::backplane::script::grpc::OpenDocumentResponse>* streamer) {
                       return this->StreamedOpenDocument(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_OpenDocument() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status OpenDocument(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::OpenDocumentRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::OpenDocumentResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedOpenDocument(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::io::deephaven::proto::backplane::script::grpc::OpenDocumentRequest,::io::deephaven::proto::backplane::script::grpc::OpenDocumentResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ChangeDocument : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ChangeDocument() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest, ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest, ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentResponse>* streamer) {
                       return this->StreamedChangeDocument(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ChangeDocument() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ChangeDocument(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedChangeDocument(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest,::io::deephaven::proto::backplane::script::grpc::ChangeDocumentResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetCompletionItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetCompletionItems() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsRequest, ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsRequest, ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse>* streamer) {
                       return this->StreamedGetCompletionItems(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetCompletionItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetCompletionItems(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetCompletionItems(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsRequest,::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CloseDocument : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CloseDocument() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::io::deephaven::proto::backplane::script::grpc::CloseDocumentRequest, ::io::deephaven::proto::backplane::script::grpc::CloseDocumentResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::io::deephaven::proto::backplane::script::grpc::CloseDocumentRequest, ::io::deephaven::proto::backplane::script::grpc::CloseDocumentResponse>* streamer) {
                       return this->StreamedCloseDocument(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CloseDocument() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CloseDocument(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::CloseDocumentRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::CloseDocumentResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCloseDocument(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::io::deephaven::proto::backplane::script::grpc::CloseDocumentRequest,::io::deephaven::proto::backplane::script::grpc::CloseDocumentResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_FetchTable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_FetchTable() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::io::deephaven::proto::backplane::script::grpc::FetchTableRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::io::deephaven::proto::backplane::script::grpc::FetchTableRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* streamer) {
                       return this->StreamedFetchTable(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_FetchTable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FetchTable(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::FetchTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFetchTable(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::io::deephaven::proto::backplane::script::grpc::FetchTableRequest,::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_FetchPandasTable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_FetchPandasTable() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::io::deephaven::proto::backplane::script::grpc::FetchPandasTableRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::io::deephaven::proto::backplane::script::grpc::FetchPandasTableRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* streamer) {
                       return this->StreamedFetchPandasTable(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_FetchPandasTable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FetchPandasTable(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::FetchPandasTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFetchPandasTable(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::io::deephaven::proto::backplane::script::grpc::FetchPandasTableRequest,::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_FetchFigure : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_FetchFigure() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::io::deephaven::proto::backplane::script::grpc::FetchFigureRequest, ::io::deephaven::proto::backplane::script::grpc::FetchFigureResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::io::deephaven::proto::backplane::script::grpc::FetchFigureRequest, ::io::deephaven::proto::backplane::script::grpc::FetchFigureResponse>* streamer) {
                       return this->StreamedFetchFigure(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_FetchFigure() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FetchFigure(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::FetchFigureRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::FetchFigureResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFetchFigure(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::io::deephaven::proto::backplane::script::grpc::FetchFigureRequest,::io::deephaven::proto::backplane::script::grpc::FetchFigureResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_FetchTableMap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_FetchTableMap() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::io::deephaven::proto::backplane::script::grpc::FetchTableMapRequest, ::io::deephaven::proto::backplane::script::grpc::FetchTableMapResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::io::deephaven::proto::backplane::script::grpc::FetchTableMapRequest, ::io::deephaven::proto::backplane::script::grpc::FetchTableMapResponse>* streamer) {
                       return this->StreamedFetchTableMap(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_FetchTableMap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FetchTableMap(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::FetchTableMapRequest* /*request*/, ::io::deephaven::proto::backplane::script::grpc::FetchTableMapResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFetchTableMap(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::io::deephaven::proto::backplane::script::grpc::FetchTableMapRequest,::io::deephaven::proto::backplane::script::grpc::FetchTableMapResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_StartConsole<WithStreamedUnaryMethod_GetConsoleTypes<WithStreamedUnaryMethod_ExecuteCommand<WithStreamedUnaryMethod_CancelCommand<WithStreamedUnaryMethod_BindTableToVariable<WithStreamedUnaryMethod_OpenDocument<WithStreamedUnaryMethod_ChangeDocument<WithStreamedUnaryMethod_GetCompletionItems<WithStreamedUnaryMethod_CloseDocument<WithStreamedUnaryMethod_FetchTable<WithStreamedUnaryMethod_FetchPandasTable<WithStreamedUnaryMethod_FetchFigure<WithStreamedUnaryMethod_FetchTableMap<Service > > > > > > > > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_SubscribeToLogs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_SubscribeToLogs() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionRequest, ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionData>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionRequest, ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionData>* streamer) {
                       return this->StreamedSubscribeToLogs(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_SubscribeToLogs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SubscribeToLogs(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionRequest* /*request*/, ::grpc::ServerWriter< ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedSubscribeToLogs(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionRequest,::io::deephaven::proto::backplane::script::grpc::LogSubscriptionData>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_SubscribeToLogs<Service > SplitStreamedService;
  typedef WithStreamedUnaryMethod_StartConsole<WithStreamedUnaryMethod_GetConsoleTypes<WithSplitStreamingMethod_SubscribeToLogs<WithStreamedUnaryMethod_ExecuteCommand<WithStreamedUnaryMethod_CancelCommand<WithStreamedUnaryMethod_BindTableToVariable<WithStreamedUnaryMethod_OpenDocument<WithStreamedUnaryMethod_ChangeDocument<WithStreamedUnaryMethod_GetCompletionItems<WithStreamedUnaryMethod_CloseDocument<WithStreamedUnaryMethod_FetchTable<WithStreamedUnaryMethod_FetchPandasTable<WithStreamedUnaryMethod_FetchFigure<WithStreamedUnaryMethod_FetchTableMap<Service > > > > > > > > > > > > > > StreamedService;
};

}  // namespace grpc
}  // namespace script
}  // namespace backplane
}  // namespace proto
}  // namespace deephaven
}  // namespace io


#endif  // GRPC_console_2eproto__INCLUDED
