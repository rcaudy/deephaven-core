// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_BARRAGE_IO_DEEPHAVEN_BARRAGE_FLATBUF_H_
#define FLATBUFFERS_GENERATED_BARRAGE_IO_DEEPHAVEN_BARRAGE_FLATBUF_H_

#include "flatbuffers/flatbuffers.h"

namespace io {
namespace deephaven {
namespace barrage {
namespace flatbuf {

struct BarrageMessageWrapper;
struct BarrageMessageWrapperBuilder;

struct NewSessionRequest;
struct NewSessionRequestBuilder;

struct RefreshSessionRequest;
struct RefreshSessionRequestBuilder;

struct SessionInfoResponse;
struct SessionInfoResponseBuilder;

struct BarrageSubscriptionRequest;
struct BarrageSubscriptionRequestBuilder;

struct BarrageModColumnMetadata;
struct BarrageModColumnMetadataBuilder;

struct BarrageUpdateMetadata;
struct BarrageUpdateMetadataBuilder;

enum BarrageMessageType : int8_t {
  BarrageMessageType_None = 0,
  BarrageMessageType_NewSessionRequest = 1,
  BarrageMessageType_RefreshSessionRequest = 2,
  BarrageMessageType_SessionInfoResponse = 3,
  BarrageMessageType_BarrageSubscriptionRequest = 4,
  BarrageMessageType_BarrageUpdateMetadata = 5,
  BarrageMessageType_MIN = BarrageMessageType_None,
  BarrageMessageType_MAX = BarrageMessageType_BarrageUpdateMetadata
};

inline const BarrageMessageType (&EnumValuesBarrageMessageType())[6] {
  static const BarrageMessageType values[] = {
    BarrageMessageType_None,
    BarrageMessageType_NewSessionRequest,
    BarrageMessageType_RefreshSessionRequest,
    BarrageMessageType_SessionInfoResponse,
    BarrageMessageType_BarrageSubscriptionRequest,
    BarrageMessageType_BarrageUpdateMetadata
  };
  return values;
}

inline const char * const *EnumNamesBarrageMessageType() {
  static const char * const names[7] = {
    "None",
    "NewSessionRequest",
    "RefreshSessionRequest",
    "SessionInfoResponse",
    "BarrageSubscriptionRequest",
    "BarrageUpdateMetadata",
    nullptr
  };
  return names;
}

inline const char *EnumNameBarrageMessageType(BarrageMessageType e) {
  if (flatbuffers::IsOutRange(e, BarrageMessageType_None, BarrageMessageType_BarrageUpdateMetadata)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBarrageMessageType()[index];
}

/// The message wrapper used for all barrage app_metadata fields.
struct BarrageMessageWrapper FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BarrageMessageWrapperBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAGIC = 4,
    VT_MSG_TYPE = 6,
    VT_MSG_PAYLOAD = 8,
    VT_RPC_TICKET = 10,
    VT_SEQUENCE = 12
  };
  /// Used to identify this type of app_metadata vs other applications. This is generated by converting "dhvn", or 0x6E687064, to the integer '1852338276'.
  uint32_t magic() const {
    return GetField<uint32_t>(VT_MAGIC, 1852338276);
  }
  /// The msg type being sent.
  io::deephaven::barrage::flatbuf::BarrageMessageType msg_type() const {
    return static_cast<io::deephaven::barrage::flatbuf::BarrageMessageType>(GetField<int8_t>(VT_MSG_TYPE, 0));
  }
  /// The msg payload.
  const flatbuffers::Vector<int8_t> *msg_payload() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_MSG_PAYLOAD);
  }
  /// Used in client-side requests to tie this message to an export id. Not required if using a client-streaming rpc.
  const flatbuffers::Vector<int8_t> *rpc_ticket() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_RPC_TICKET);
  }
  /// Used in client-side requests to sequence this message w.r.t. other messages sent to the same rpcTicket. Not required if using a client-streaming rpc.
  int64_t sequence() const {
    return GetField<int64_t>(VT_SEQUENCE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_MAGIC) &&
           VerifyField<int8_t>(verifier, VT_MSG_TYPE) &&
           VerifyOffset(verifier, VT_MSG_PAYLOAD) &&
           verifier.VerifyVector(msg_payload()) &&
           VerifyOffset(verifier, VT_RPC_TICKET) &&
           verifier.VerifyVector(rpc_ticket()) &&
           VerifyField<int64_t>(verifier, VT_SEQUENCE) &&
           verifier.EndTable();
  }
};

struct BarrageMessageWrapperBuilder {
  typedef BarrageMessageWrapper Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_magic(uint32_t magic) {
    fbb_.AddElement<uint32_t>(BarrageMessageWrapper::VT_MAGIC, magic, 1852338276);
  }
  void add_msg_type(io::deephaven::barrage::flatbuf::BarrageMessageType msg_type) {
    fbb_.AddElement<int8_t>(BarrageMessageWrapper::VT_MSG_TYPE, static_cast<int8_t>(msg_type), 0);
  }
  void add_msg_payload(flatbuffers::Offset<flatbuffers::Vector<int8_t>> msg_payload) {
    fbb_.AddOffset(BarrageMessageWrapper::VT_MSG_PAYLOAD, msg_payload);
  }
  void add_rpc_ticket(flatbuffers::Offset<flatbuffers::Vector<int8_t>> rpc_ticket) {
    fbb_.AddOffset(BarrageMessageWrapper::VT_RPC_TICKET, rpc_ticket);
  }
  void add_sequence(int64_t sequence) {
    fbb_.AddElement<int64_t>(BarrageMessageWrapper::VT_SEQUENCE, sequence, 0);
  }
  explicit BarrageMessageWrapperBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BarrageMessageWrapper> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BarrageMessageWrapper>(end);
    return o;
  }
};

inline flatbuffers::Offset<BarrageMessageWrapper> CreateBarrageMessageWrapper(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t magic = 1852338276,
    io::deephaven::barrage::flatbuf::BarrageMessageType msg_type = io::deephaven::barrage::flatbuf::BarrageMessageType_None,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> msg_payload = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> rpc_ticket = 0,
    int64_t sequence = 0) {
  BarrageMessageWrapperBuilder builder_(_fbb);
  builder_.add_sequence(sequence);
  builder_.add_rpc_ticket(rpc_ticket);
  builder_.add_msg_payload(msg_payload);
  builder_.add_magic(magic);
  builder_.add_msg_type(msg_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<BarrageMessageWrapper> CreateBarrageMessageWrapperDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t magic = 1852338276,
    io::deephaven::barrage::flatbuf::BarrageMessageType msg_type = io::deephaven::barrage::flatbuf::BarrageMessageType_None,
    const std::vector<int8_t> *msg_payload = nullptr,
    const std::vector<int8_t> *rpc_ticket = nullptr,
    int64_t sequence = 0) {
  auto msg_payload__ = msg_payload ? _fbb.CreateVector<int8_t>(*msg_payload) : 0;
  auto rpc_ticket__ = rpc_ticket ? _fbb.CreateVector<int8_t>(*rpc_ticket) : 0;
  return io::deephaven::barrage::flatbuf::CreateBarrageMessageWrapper(
      _fbb,
      magic,
      msg_type,
      msg_payload__,
      rpc_ticket__,
      sequence);
}

/// Establish a new session.
struct NewSessionRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NewSessionRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct NewSessionRequestBuilder {
  typedef NewSessionRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit NewSessionRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<NewSessionRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NewSessionRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<NewSessionRequest> CreateNewSessionRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  NewSessionRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// Refresh the provided session.
struct RefreshSessionRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RefreshSessionRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SESSION = 4
  };
  /// this session token is only required if it is the first request of an rpc stream
  const flatbuffers::Vector<int8_t> *session() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_SESSION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SESSION) &&
           verifier.VerifyVector(session()) &&
           verifier.EndTable();
  }
};

struct RefreshSessionRequestBuilder {
  typedef RefreshSessionRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_session(flatbuffers::Offset<flatbuffers::Vector<int8_t>> session) {
    fbb_.AddOffset(RefreshSessionRequest::VT_SESSION, session);
  }
  explicit RefreshSessionRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RefreshSessionRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RefreshSessionRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<RefreshSessionRequest> CreateRefreshSessionRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> session = 0) {
  RefreshSessionRequestBuilder builder_(_fbb);
  builder_.add_session(session);
  return builder_.Finish();
}

inline flatbuffers::Offset<RefreshSessionRequest> CreateRefreshSessionRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *session = nullptr) {
  auto session__ = session ? _fbb.CreateVector<int8_t>(*session) : 0;
  return io::deephaven::barrage::flatbuf::CreateRefreshSessionRequest(
      _fbb,
      session__);
}

/// Information about the current session state.
struct SessionInfoResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SessionInfoResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_METADATA_HEADER = 4,
    VT_SESSION_TOKEN = 6,
    VT_TOKEN_REFRESH_DEADLINE_MILLIS = 8
  };
  /// this is the metadata header to identify this session with future requests; it must be lower-case and remain static for the life of the session
  const flatbuffers::Vector<int8_t> *metadata_header() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_METADATA_HEADER);
  }
  /// this is the session_token; note that it may rotate
  const flatbuffers::Vector<int8_t> *session_token() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_SESSION_TOKEN);
  }
  /// a suggested time for the user to refresh the session if they do not do so earlier; value is denoted in milliseconds since epoch
  int64_t token_refresh_deadline_millis() const {
    return GetField<int64_t>(VT_TOKEN_REFRESH_DEADLINE_MILLIS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_METADATA_HEADER) &&
           verifier.VerifyVector(metadata_header()) &&
           VerifyOffset(verifier, VT_SESSION_TOKEN) &&
           verifier.VerifyVector(session_token()) &&
           VerifyField<int64_t>(verifier, VT_TOKEN_REFRESH_DEADLINE_MILLIS) &&
           verifier.EndTable();
  }
};

struct SessionInfoResponseBuilder {
  typedef SessionInfoResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_metadata_header(flatbuffers::Offset<flatbuffers::Vector<int8_t>> metadata_header) {
    fbb_.AddOffset(SessionInfoResponse::VT_METADATA_HEADER, metadata_header);
  }
  void add_session_token(flatbuffers::Offset<flatbuffers::Vector<int8_t>> session_token) {
    fbb_.AddOffset(SessionInfoResponse::VT_SESSION_TOKEN, session_token);
  }
  void add_token_refresh_deadline_millis(int64_t token_refresh_deadline_millis) {
    fbb_.AddElement<int64_t>(SessionInfoResponse::VT_TOKEN_REFRESH_DEADLINE_MILLIS, token_refresh_deadline_millis, 0);
  }
  explicit SessionInfoResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SessionInfoResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SessionInfoResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<SessionInfoResponse> CreateSessionInfoResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> metadata_header = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> session_token = 0,
    int64_t token_refresh_deadline_millis = 0) {
  SessionInfoResponseBuilder builder_(_fbb);
  builder_.add_token_refresh_deadline_millis(token_refresh_deadline_millis);
  builder_.add_session_token(session_token);
  builder_.add_metadata_header(metadata_header);
  return builder_.Finish();
}

inline flatbuffers::Offset<SessionInfoResponse> CreateSessionInfoResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *metadata_header = nullptr,
    const std::vector<int8_t> *session_token = nullptr,
    int64_t token_refresh_deadline_millis = 0) {
  auto metadata_header__ = metadata_header ? _fbb.CreateVector<int8_t>(*metadata_header) : 0;
  auto session_token__ = session_token ? _fbb.CreateVector<int8_t>(*session_token) : 0;
  return io::deephaven::barrage::flatbuf::CreateSessionInfoResponse(
      _fbb,
      metadata_header__,
      session_token__,
      token_refresh_deadline_millis);
}

/// Describes the subscription the client would like to acquire.
struct BarrageSubscriptionRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BarrageSubscriptionRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TICKET = 4,
    VT_COLUMNS = 6,
    VT_VIEWPORT = 8,
    VT_UPDATE_INTERVAL_MS = 10,
    VT_EXPORT_TICKET = 12,
    VT_USE_DEEPHAVEN_NULLS = 14
  };
  /// Ticket for the source data set.
  const flatbuffers::Vector<int8_t> *ticket() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_TICKET);
  }
  /// The bitset of columns to subscribe to. An empty bitset unsubscribes from all columns.
  const flatbuffers::Vector<int8_t> *columns() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_COLUMNS);
  }
  /// This is an encoded Index of rows in position-space to subscribe to.
  const flatbuffers::Vector<int8_t> *viewport() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_VIEWPORT);
  }
  /// Explicitly set the update interval for this subscription. Note that subscriptions with different update intervals
  /// cannot share intermediary state with other subscriptions and greatly increases the footprint of the non-conforming subscription.
  int64_t update_interval_ms() const {
    return GetField<int64_t>(VT_UPDATE_INTERVAL_MS, 0);
  }
  /// Ticket to export this subscription request for out-of-band updates.
  const flatbuffers::Vector<int8_t> *export_ticket() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_EXPORT_TICKET);
  }
  /// Deephaven reserves a value in the range of primitives as a custom NULL value. This enables more efficient transmission
  /// by eliminating the additional complexity of the validity buffer.
  bool use_deephaven_nulls() const {
    return GetField<uint8_t>(VT_USE_DEEPHAVEN_NULLS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TICKET) &&
           verifier.VerifyVector(ticket()) &&
           VerifyOffset(verifier, VT_COLUMNS) &&
           verifier.VerifyVector(columns()) &&
           VerifyOffset(verifier, VT_VIEWPORT) &&
           verifier.VerifyVector(viewport()) &&
           VerifyField<int64_t>(verifier, VT_UPDATE_INTERVAL_MS) &&
           VerifyOffset(verifier, VT_EXPORT_TICKET) &&
           verifier.VerifyVector(export_ticket()) &&
           VerifyField<uint8_t>(verifier, VT_USE_DEEPHAVEN_NULLS) &&
           verifier.EndTable();
  }
};

struct BarrageSubscriptionRequestBuilder {
  typedef BarrageSubscriptionRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ticket(flatbuffers::Offset<flatbuffers::Vector<int8_t>> ticket) {
    fbb_.AddOffset(BarrageSubscriptionRequest::VT_TICKET, ticket);
  }
  void add_columns(flatbuffers::Offset<flatbuffers::Vector<int8_t>> columns) {
    fbb_.AddOffset(BarrageSubscriptionRequest::VT_COLUMNS, columns);
  }
  void add_viewport(flatbuffers::Offset<flatbuffers::Vector<int8_t>> viewport) {
    fbb_.AddOffset(BarrageSubscriptionRequest::VT_VIEWPORT, viewport);
  }
  void add_update_interval_ms(int64_t update_interval_ms) {
    fbb_.AddElement<int64_t>(BarrageSubscriptionRequest::VT_UPDATE_INTERVAL_MS, update_interval_ms, 0);
  }
  void add_export_ticket(flatbuffers::Offset<flatbuffers::Vector<int8_t>> export_ticket) {
    fbb_.AddOffset(BarrageSubscriptionRequest::VT_EXPORT_TICKET, export_ticket);
  }
  void add_use_deephaven_nulls(bool use_deephaven_nulls) {
    fbb_.AddElement<uint8_t>(BarrageSubscriptionRequest::VT_USE_DEEPHAVEN_NULLS, static_cast<uint8_t>(use_deephaven_nulls), 0);
  }
  explicit BarrageSubscriptionRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BarrageSubscriptionRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BarrageSubscriptionRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<BarrageSubscriptionRequest> CreateBarrageSubscriptionRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> ticket = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> columns = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> viewport = 0,
    int64_t update_interval_ms = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> export_ticket = 0,
    bool use_deephaven_nulls = false) {
  BarrageSubscriptionRequestBuilder builder_(_fbb);
  builder_.add_update_interval_ms(update_interval_ms);
  builder_.add_export_ticket(export_ticket);
  builder_.add_viewport(viewport);
  builder_.add_columns(columns);
  builder_.add_ticket(ticket);
  builder_.add_use_deephaven_nulls(use_deephaven_nulls);
  return builder_.Finish();
}

inline flatbuffers::Offset<BarrageSubscriptionRequest> CreateBarrageSubscriptionRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *ticket = nullptr,
    const std::vector<int8_t> *columns = nullptr,
    const std::vector<int8_t> *viewport = nullptr,
    int64_t update_interval_ms = 0,
    const std::vector<int8_t> *export_ticket = nullptr,
    bool use_deephaven_nulls = false) {
  auto ticket__ = ticket ? _fbb.CreateVector<int8_t>(*ticket) : 0;
  auto columns__ = columns ? _fbb.CreateVector<int8_t>(*columns) : 0;
  auto viewport__ = viewport ? _fbb.CreateVector<int8_t>(*viewport) : 0;
  auto export_ticket__ = export_ticket ? _fbb.CreateVector<int8_t>(*export_ticket) : 0;
  return io::deephaven::barrage::flatbuf::CreateBarrageSubscriptionRequest(
      _fbb,
      ticket__,
      columns__,
      viewport__,
      update_interval_ms,
      export_ticket__,
      use_deephaven_nulls);
}

/// Holds all of the index data structures for the column being modified.
struct BarrageModColumnMetadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BarrageModColumnMetadataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODIFIED_ROWS = 4
  };
  /// This is an encoded Index of rows for this column (within the viewport) that were modified.
  /// There is no notification for modifications outside of the viewport.
  const flatbuffers::Vector<int8_t> *modified_rows() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_MODIFIED_ROWS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MODIFIED_ROWS) &&
           verifier.VerifyVector(modified_rows()) &&
           verifier.EndTable();
  }
};

struct BarrageModColumnMetadataBuilder {
  typedef BarrageModColumnMetadata Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_modified_rows(flatbuffers::Offset<flatbuffers::Vector<int8_t>> modified_rows) {
    fbb_.AddOffset(BarrageModColumnMetadata::VT_MODIFIED_ROWS, modified_rows);
  }
  explicit BarrageModColumnMetadataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BarrageModColumnMetadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BarrageModColumnMetadata>(end);
    return o;
  }
};

inline flatbuffers::Offset<BarrageModColumnMetadata> CreateBarrageModColumnMetadata(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> modified_rows = 0) {
  BarrageModColumnMetadataBuilder builder_(_fbb);
  builder_.add_modified_rows(modified_rows);
  return builder_.Finish();
}

inline flatbuffers::Offset<BarrageModColumnMetadata> CreateBarrageModColumnMetadataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *modified_rows = nullptr) {
  auto modified_rows__ = modified_rows ? _fbb.CreateVector<int8_t>(*modified_rows) : 0;
  return io::deephaven::barrage::flatbuf::CreateBarrageModColumnMetadata(
      _fbb,
      modified_rows__);
}

/// A data header describing the shared memory layout of a "record" or "row"
/// batch for a ticking barrage table.
struct BarrageUpdateMetadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BarrageUpdateMetadataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUM_ADD_BATCHES = 4,
    VT_NUM_MOD_BATCHES = 6,
    VT_FIRST_SEQ = 8,
    VT_LAST_SEQ = 10,
    VT_IS_SNAPSHOT = 12,
    VT_EFFECTIVE_VIEWPORT = 14,
    VT_EFFECTIVE_COLUMN_SET = 16,
    VT_ADDED_ROWS = 18,
    VT_REMOVED_ROWS = 20,
    VT_SHIFT_DATA = 22,
    VT_ADDED_COLUMN_SET = 24,
    VT_MODIFIED_COLUMN_SET = 26,
    VT_ADDED_ROWS_INCLUDED = 28,
    VT_NODES = 30
  };
  /// The number of record batches that describe rows added (may be zero).
  uint16_t num_add_batches() const {
    return GetField<uint16_t>(VT_NUM_ADD_BATCHES, 0);
  }
  /// The number of record batches that describe rows modified (may be zero).
  uint16_t num_mod_batches() const {
    return GetField<uint16_t>(VT_NUM_MOD_BATCHES, 0);
  }
  /// This batch is generated from an upstream table that ticks independently of the stream. If
  /// multiple events are coalesced into one update, the server may communicate that here for
  /// informational purposes.
  int64_t first_seq() const {
    return GetField<int64_t>(VT_FIRST_SEQ, 0);
  }
  int64_t last_seq() const {
    return GetField<int64_t>(VT_LAST_SEQ, 0);
  }
  /// Indicates if this message was sent due to upstream ticks or due to a subscription change.
  bool is_snapshot() const {
    return GetField<uint8_t>(VT_IS_SNAPSHOT, 0) != 0;
  }
  /// If this is a snapshot and the subscription is a viewport, then the effectively subscribed viewport
  /// will be included in the payload. It is an encoded Index.
  const flatbuffers::Vector<int8_t> *effective_viewport() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_EFFECTIVE_VIEWPORT);
  }
  /// If this is a snapshot, then the effectively subscribed column set will be included in the payload.
  const flatbuffers::Vector<int8_t> *effective_column_set() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_EFFECTIVE_COLUMN_SET);
  }
  /// This is an encoded Index of rows that were added in this update.
  const flatbuffers::Vector<int8_t> *added_rows() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_ADDED_ROWS);
  }
  /// This is an encoded Index of rows that were removed in this update.
  const flatbuffers::Vector<int8_t> *removed_rows() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_REMOVED_ROWS);
  }
  /// This is an encoded IndexShiftData describing how the keyspace of unmodified rows changed.
  const flatbuffers::Vector<int8_t> *shift_data() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_SHIFT_DATA);
  }
  /// This is an encoded bitset of added columns that are included in this update; it will match the most
  /// recently received effectiveColumnSet.
  const flatbuffers::Vector<int8_t> *added_column_set() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_ADDED_COLUMN_SET);
  }
  /// This is an encoded bitset of modified columns that are included in this update. If this is a
  /// snapshot, then this bitset will be empty.
  const flatbuffers::Vector<int8_t> *modified_column_set() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_MODIFIED_COLUMN_SET);
  }
  /// This is an encoded Index of rows that were included with this update
  /// (the server may include rows not in addedRows if this is a viewport subscription to refresh
  ///  unmodified rows that were scoped into view)
  const flatbuffers::Vector<int8_t> *added_rows_included() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_ADDED_ROWS_INCLUDED);
  }
  /// The list of modified column data are the modified indices for each modified column indicated in modified column set.
  const flatbuffers::Vector<flatbuffers::Offset<io::deephaven::barrage::flatbuf::BarrageModColumnMetadata>> *nodes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<io::deephaven::barrage::flatbuf::BarrageModColumnMetadata>> *>(VT_NODES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_NUM_ADD_BATCHES) &&
           VerifyField<uint16_t>(verifier, VT_NUM_MOD_BATCHES) &&
           VerifyField<int64_t>(verifier, VT_FIRST_SEQ) &&
           VerifyField<int64_t>(verifier, VT_LAST_SEQ) &&
           VerifyField<uint8_t>(verifier, VT_IS_SNAPSHOT) &&
           VerifyOffset(verifier, VT_EFFECTIVE_VIEWPORT) &&
           verifier.VerifyVector(effective_viewport()) &&
           VerifyOffset(verifier, VT_EFFECTIVE_COLUMN_SET) &&
           verifier.VerifyVector(effective_column_set()) &&
           VerifyOffset(verifier, VT_ADDED_ROWS) &&
           verifier.VerifyVector(added_rows()) &&
           VerifyOffset(verifier, VT_REMOVED_ROWS) &&
           verifier.VerifyVector(removed_rows()) &&
           VerifyOffset(verifier, VT_SHIFT_DATA) &&
           verifier.VerifyVector(shift_data()) &&
           VerifyOffset(verifier, VT_ADDED_COLUMN_SET) &&
           verifier.VerifyVector(added_column_set()) &&
           VerifyOffset(verifier, VT_MODIFIED_COLUMN_SET) &&
           verifier.VerifyVector(modified_column_set()) &&
           VerifyOffset(verifier, VT_ADDED_ROWS_INCLUDED) &&
           verifier.VerifyVector(added_rows_included()) &&
           VerifyOffset(verifier, VT_NODES) &&
           verifier.VerifyVector(nodes()) &&
           verifier.VerifyVectorOfTables(nodes()) &&
           verifier.EndTable();
  }
};

struct BarrageUpdateMetadataBuilder {
  typedef BarrageUpdateMetadata Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_num_add_batches(uint16_t num_add_batches) {
    fbb_.AddElement<uint16_t>(BarrageUpdateMetadata::VT_NUM_ADD_BATCHES, num_add_batches, 0);
  }
  void add_num_mod_batches(uint16_t num_mod_batches) {
    fbb_.AddElement<uint16_t>(BarrageUpdateMetadata::VT_NUM_MOD_BATCHES, num_mod_batches, 0);
  }
  void add_first_seq(int64_t first_seq) {
    fbb_.AddElement<int64_t>(BarrageUpdateMetadata::VT_FIRST_SEQ, first_seq, 0);
  }
  void add_last_seq(int64_t last_seq) {
    fbb_.AddElement<int64_t>(BarrageUpdateMetadata::VT_LAST_SEQ, last_seq, 0);
  }
  void add_is_snapshot(bool is_snapshot) {
    fbb_.AddElement<uint8_t>(BarrageUpdateMetadata::VT_IS_SNAPSHOT, static_cast<uint8_t>(is_snapshot), 0);
  }
  void add_effective_viewport(flatbuffers::Offset<flatbuffers::Vector<int8_t>> effective_viewport) {
    fbb_.AddOffset(BarrageUpdateMetadata::VT_EFFECTIVE_VIEWPORT, effective_viewport);
  }
  void add_effective_column_set(flatbuffers::Offset<flatbuffers::Vector<int8_t>> effective_column_set) {
    fbb_.AddOffset(BarrageUpdateMetadata::VT_EFFECTIVE_COLUMN_SET, effective_column_set);
  }
  void add_added_rows(flatbuffers::Offset<flatbuffers::Vector<int8_t>> added_rows) {
    fbb_.AddOffset(BarrageUpdateMetadata::VT_ADDED_ROWS, added_rows);
  }
  void add_removed_rows(flatbuffers::Offset<flatbuffers::Vector<int8_t>> removed_rows) {
    fbb_.AddOffset(BarrageUpdateMetadata::VT_REMOVED_ROWS, removed_rows);
  }
  void add_shift_data(flatbuffers::Offset<flatbuffers::Vector<int8_t>> shift_data) {
    fbb_.AddOffset(BarrageUpdateMetadata::VT_SHIFT_DATA, shift_data);
  }
  void add_added_column_set(flatbuffers::Offset<flatbuffers::Vector<int8_t>> added_column_set) {
    fbb_.AddOffset(BarrageUpdateMetadata::VT_ADDED_COLUMN_SET, added_column_set);
  }
  void add_modified_column_set(flatbuffers::Offset<flatbuffers::Vector<int8_t>> modified_column_set) {
    fbb_.AddOffset(BarrageUpdateMetadata::VT_MODIFIED_COLUMN_SET, modified_column_set);
  }
  void add_added_rows_included(flatbuffers::Offset<flatbuffers::Vector<int8_t>> added_rows_included) {
    fbb_.AddOffset(BarrageUpdateMetadata::VT_ADDED_ROWS_INCLUDED, added_rows_included);
  }
  void add_nodes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<io::deephaven::barrage::flatbuf::BarrageModColumnMetadata>>> nodes) {
    fbb_.AddOffset(BarrageUpdateMetadata::VT_NODES, nodes);
  }
  explicit BarrageUpdateMetadataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BarrageUpdateMetadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BarrageUpdateMetadata>(end);
    return o;
  }
};

inline flatbuffers::Offset<BarrageUpdateMetadata> CreateBarrageUpdateMetadata(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t num_add_batches = 0,
    uint16_t num_mod_batches = 0,
    int64_t first_seq = 0,
    int64_t last_seq = 0,
    bool is_snapshot = false,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> effective_viewport = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> effective_column_set = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> added_rows = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> removed_rows = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> shift_data = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> added_column_set = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> modified_column_set = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> added_rows_included = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<io::deephaven::barrage::flatbuf::BarrageModColumnMetadata>>> nodes = 0) {
  BarrageUpdateMetadataBuilder builder_(_fbb);
  builder_.add_last_seq(last_seq);
  builder_.add_first_seq(first_seq);
  builder_.add_nodes(nodes);
  builder_.add_added_rows_included(added_rows_included);
  builder_.add_modified_column_set(modified_column_set);
  builder_.add_added_column_set(added_column_set);
  builder_.add_shift_data(shift_data);
  builder_.add_removed_rows(removed_rows);
  builder_.add_added_rows(added_rows);
  builder_.add_effective_column_set(effective_column_set);
  builder_.add_effective_viewport(effective_viewport);
  builder_.add_num_mod_batches(num_mod_batches);
  builder_.add_num_add_batches(num_add_batches);
  builder_.add_is_snapshot(is_snapshot);
  return builder_.Finish();
}

inline flatbuffers::Offset<BarrageUpdateMetadata> CreateBarrageUpdateMetadataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t num_add_batches = 0,
    uint16_t num_mod_batches = 0,
    int64_t first_seq = 0,
    int64_t last_seq = 0,
    bool is_snapshot = false,
    const std::vector<int8_t> *effective_viewport = nullptr,
    const std::vector<int8_t> *effective_column_set = nullptr,
    const std::vector<int8_t> *added_rows = nullptr,
    const std::vector<int8_t> *removed_rows = nullptr,
    const std::vector<int8_t> *shift_data = nullptr,
    const std::vector<int8_t> *added_column_set = nullptr,
    const std::vector<int8_t> *modified_column_set = nullptr,
    const std::vector<int8_t> *added_rows_included = nullptr,
    const std::vector<flatbuffers::Offset<io::deephaven::barrage::flatbuf::BarrageModColumnMetadata>> *nodes = nullptr) {
  auto effective_viewport__ = effective_viewport ? _fbb.CreateVector<int8_t>(*effective_viewport) : 0;
  auto effective_column_set__ = effective_column_set ? _fbb.CreateVector<int8_t>(*effective_column_set) : 0;
  auto added_rows__ = added_rows ? _fbb.CreateVector<int8_t>(*added_rows) : 0;
  auto removed_rows__ = removed_rows ? _fbb.CreateVector<int8_t>(*removed_rows) : 0;
  auto shift_data__ = shift_data ? _fbb.CreateVector<int8_t>(*shift_data) : 0;
  auto added_column_set__ = added_column_set ? _fbb.CreateVector<int8_t>(*added_column_set) : 0;
  auto modified_column_set__ = modified_column_set ? _fbb.CreateVector<int8_t>(*modified_column_set) : 0;
  auto added_rows_included__ = added_rows_included ? _fbb.CreateVector<int8_t>(*added_rows_included) : 0;
  auto nodes__ = nodes ? _fbb.CreateVector<flatbuffers::Offset<io::deephaven::barrage::flatbuf::BarrageModColumnMetadata>>(*nodes) : 0;
  return io::deephaven::barrage::flatbuf::CreateBarrageUpdateMetadata(
      _fbb,
      num_add_batches,
      num_mod_batches,
      first_seq,
      last_seq,
      is_snapshot,
      effective_viewport__,
      effective_column_set__,
      added_rows__,
      removed_rows__,
      shift_data__,
      added_column_set__,
      modified_column_set__,
      added_rows_included__,
      nodes__);
}

}  // namespace flatbuf
}  // namespace barrage
}  // namespace deephaven
}  // namespace io

#endif  // FLATBUFFERS_GENERATED_BARRAGE_IO_DEEPHAVEN_BARRAGE_FLATBUF_H_
